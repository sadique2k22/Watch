<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Echo Hybrid - Color Shift Edition</title>
    <style>
        body { margin: 0; background: #ffffff; overflow: hidden; font-family: sans-serif; }
        #ui { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            color: #ff6600; letter-spacing: 5px; font-size: 10px; opacity: 0.6; 
            pointer-events: none; text-transform: uppercase; 
        }
    </style>
</head>
<body>

<div id="ui">Magnetic Activation // Orange to Black Transition</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- 1. SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(10, 20, 15);
scene.add(sun);

const watchGroup = new THREE.Group();
scene.add(watchGroup);

const radius = 35;
const gap = 16;
const orangeColor = new THREE.Color(0xff6600);
const blackColor = new THREE.Color(0x000000);

// Orange Base
const base = new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 2, 64),
    new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.8 })
);
base.position.y = -gap/2;
watchGroup.add(base);

// Translucent Glass
const glass = new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 1.5, 64),
    new THREE.MeshPhysicalMaterial({
        color: 0xeef5ff, transparent: true, opacity: 0.4,
        transmission: 0.3, thickness: 2, roughness: 0.1, clearcoat: 1
    })
);
glass.position.y = gap/2;
watchGroup.add(glass);

// --- 2. PARTICLE LOGIC WITH VERTEX COLORS ---
const count = 400000; 
const pGeo = new THREE.BufferGeometry();
const posArray = new Float32Array(count * 3);
const colorArray = new Float32Array(count * 3); // Current RGB
const targetPosArray = new Float32Array(count * 3);
const targetColorArray = new Float32Array(count * 3); // Target RGB

for (let i = 0; i < count; i++) {
    const r = radius * Math.sqrt(Math.random());
    const theta = Math.random() * Math.PI * 2;
    const i3 = i * 3;

    posArray[i3] = Math.cos(theta) * r;
    posArray[i3 + 1] = -gap/2 + 1; 
    posArray[i3 + 2] = Math.sin(theta) * r;
    
    targetPosArray[i3] = posArray[i3];
    targetPosArray[i3 + 1] = posArray[i3 + 1];
    targetPosArray[i3 + 2] = posArray[i3 + 2];

    // Start all as orange
    colorArray[i3] = orangeColor.r;
    colorArray[i3+1] = orangeColor.g;
    colorArray[i3+2] = orangeColor.b;

    targetColorArray[i3] = orangeColor.r;
    targetColorArray[i3+1] = orangeColor.g;
    targetColorArray[i3+2] = orangeColor.b;
}

pGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
pGeo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

const pMat = new THREE.PointsMaterial({ 
    size: 0.22, 
    vertexColors: true, // Crucial for per-particle coloring
    transparent: true, 
    opacity: 0.9 
});
const points = new THREE.Points(pGeo, pMat);
watchGroup.add(points);

// --- 3. DIGIT SAMPLER ---
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 64; canvas.height = 64;
const digitCache = {};

function getDigitPoints(text) {
    if (digitCache[text]) return digitCache[text];
    ctx.clearRect(0, 0, 64, 64);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 30px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 32, 32);
    const data = ctx.getImageData(0, 0, 64, 64).data;
    const pts = [];
    for (let y = 0; y < 64; y += 2) {
        for (let x = 0; x < 64; x += 2) {
            if (data[(y * 64 + x) * 4] > 120) {
                pts.push({ x: (x - 32) * 0.15, z: (y - 32) * 0.15 });
            }
        }
    }
    digitCache[text] = pts;
    return pts;
}

// --- 4. ANIMATION & TRANSITION LOGIC ---
const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 100, 110);
controls.enableDamping = true;

let lastSec = -1;

function animate() {
    requestAnimationFrame(animate);
    const d = new Date();
    const ms = d.getMilliseconds();
    const s = d.getSeconds() + ms/1000;
    const m = d.getMinutes() + s/60;
    const h = (d.getHours() % 12) + m/60;

    const currentSecInt = Math.floor(s);

    if (currentSecInt !== lastSec) {
        const hPts = getDigitPoints(Math.floor(h || 12).toString().padStart(2, '0'));
        const mPts = getDigitPoints(Math.floor(m).toString().padStart(2, '0'));
        const sPts = getDigitPoints(currentSecInt.toString().padStart(2, '0'));

        let pIdx = 0;

        const formHand = (pts, repeats, rStart, rStep, angleStepVal, val) => {
            const angle = (90 - (val * angleStepVal)) * (Math.PI / 180);
            for (let r = 0; r < repeats; r++) {
                const dist = rStart + (r * rStep);
                const cx = Math.cos(angle) * dist;
                const cz = -Math.sin(angle) * dist;
                
                for (let j = 0; j < pts.length; j++) {
                    if (pIdx >= count) break;
                    const i3 = pIdx * 3;
                    targetPosArray[i3] = cx + pts[j].x;
                    targetPosArray[i3+1] = gap/2 - 0.5; 
                    targetPosArray[i3+2] = cz + pts[j].z;
                    
                    // Set target color to BLACK when jumping up
                    targetColorArray[i3] = blackColor.r;
                    targetColorArray[i3+1] = blackColor.g;
                    targetColorArray[i3+2] = blackColor.b;
                    pIdx++;
                }
            }
        };

        formHand(hPts, 4, 4, 4.5, 30, h);
        formHand(mPts, 7, 4, 4.0, 6, m);
        formHand(sPts, 5, 4, 5.0, 6, s);

        while (pIdx < count) {
            const i3 = pIdx * 3;
            // Only update those that were previously up or need moving
            if (targetPosArray[i3+1] > 0) { 
                const r = radius * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                targetPosArray[i3] = Math.cos(theta) * r;
                targetPosArray[i3+1] = -gap/2 + 1;
                targetPosArray[i3+2] = Math.sin(theta) * r;

                // Set target color back to ORANGE when falling down
                targetColorArray[i3] = orangeColor.r;
                targetColorArray[i3+1] = orangeColor.g;
                targetColorArray[i3+2] = orangeColor.b;
            }
            pIdx++;
        }
        lastSec = currentSecInt;
    }

    const pos = points.geometry.attributes.position.array;
    const col = points.geometry.attributes.color.array;

    for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const lerpSpeed = pos[i3+1] < targetPosArray[i3+1] ? 0.15 : 0.08;
        
        // Position Lerp
        pos[i3] += (targetPosArray[i3] - pos[i3]) * lerpSpeed;
        pos[i3+1] += (targetPosArray[i3+1] - pos[i3+1]) * lerpSpeed;
        pos[i3+2] += (targetPosArray[i3+2] - pos[i3+2]) * lerpSpeed;

        // Color Lerp (fades between orange and black)
        col[i3] += (targetColorArray[i3] - col[i3]) * 0.1;
        col[i3+1] += (targetColorArray[i3+1] - col[i3+1]) * 0.1;
        col[i3+2] += (targetColorArray[i3+2] - col[i3+2]) * 0.1;
    }
    
    points.geometry.attributes.position.needsUpdate = true;
    points.geometry.attributes.color.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
}

animate();
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>