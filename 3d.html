<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Echo Watch - Perfect Vision</title>
  <style>
    body { margin: 0; background: #050505; overflow: hidden; font-family: 'Inter', sans-serif; }
    #ui { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #00ffcc; letter-spacing: 8px; font-size: 10px; opacity: 0.7; pointer-events: none; text-transform: uppercase; }
  </style>
</head>
<body>

<div id="ui">Magnetic Fluid // Sadique2k22</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- SCENE SETUP ---
const scene = new THREE.Scene();
// Narrower FOV for a "Telephoto" product look
const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

// --- LIGHTING ---
const ambient = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 3);
sun.position.set(5, 5, 10);
scene.add(sun);

// Rim light for the metal edge
const rim = new THREE.SpotLight(0x00ffcc, 10);
rim.position.set(-5, 0, 5);
scene.add(rim);

// --- MATERIALS ---
// 1. Dark Brushed Metal
const metalMat = new THREE.MeshStandardMaterial({
  color: 0x111111,
  metalness: 0.9,
  roughness: 0.2
});

// 2. Matte Dial Plate
const dialMat = new THREE.MeshStandardMaterial({
  color: 0x050505,
  roughness: 0.9,
  metalness: 0.1
});

// 3. Clear Crystal (No distortion)
const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0,
  roughness: 0,
  transmission: 0.98, // Very clear
  thickness: 0.1,     // Thin to prevent warping
  transparent: true,
  opacity: 0.1,
  side: THREE.DoubleSide
});

// --- WATCH BODY ---
const watchGroup = new THREE.Group();
scene.add(watchGroup);

// Case
const caseMesh = new THREE.Mesh(new THREE.CylinderGeometry(4.8, 4.8, 1.2, 64), metalMat);
caseMesh.rotation.x = Math.PI / 2;
caseMesh.position.z = -0.6;
watchGroup.add(caseMesh);

// Bezel
const bezel = new THREE.Mesh(new THREE.TorusGeometry(4.7, 0.15, 16, 100), metalMat);
bezel.position.z = 0.2;
watchGroup.add(bezel);

// Inner Dial (Background)
const dial = new THREE.Mesh(new THREE.CircleGeometry(4.6, 64), dialMat);
dial.position.z = -0.1; // Just behind the particles
watchGroup.add(dial);

// Glass Cover (Floating above)
const glass = new THREE.Mesh(new THREE.SphereGeometry(4.7, 64, 32, 0, Math.PI*2, 0, 0.3), glassMat);
glass.rotation.x = -Math.PI / 2;
glass.position.z = 0.3; 
watchGroup.add(glass);

// --- PARTICLE LOGIC (RESTORED TO PERFECT VERSION) ---
const pMat = new THREE.PointsMaterial({
  color: 0x00ffcc,
  size: 0.015, // Fine dust size
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthTest: false, // Always show on top of dial
  depthWrite: false
});

const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 128; canvas.height = 128;

const digitCache = {};
function getPoints(text) {
  if (digitCache[text]) return digitCache[text];

  // The "Perfect" Settings you liked:
  ctx.clearRect(0, 0, 128, 128);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 44px Arial'; 
  ctx.textAlign = 'center'; 
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 64, 64);

  const data = ctx.getImageData(0, 0, 128, 128).data;
  const pts = [];
  for (let y = 0; y < 128; y += 2) {
    for (let x = 0; x < 128; x += 2) {
      if (data[(y * 128 + x) * 4] > 120) {
        // Divisor 105: The sweet spot for size
        pts.push({ x: (x - 64) / 105, y: (64 - y) / 105 });
      }
    }
  }
  digitCache[text] = pts;
  return pts;
}

function createSys(count, echoes) {
  const systems = [];
  for (let i = 0; i < echoes; i++) {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
    const p = new THREE.Points(geo, pMat.clone());
    // Slight Z-lift so they don't touch the dial
    p.position.z = 0.05 + (i * 0.02);
    watchGroup.add(p);
    systems.push(p);
  }
  return systems;
}

// Counts from "Perfect" version
const hSys = createSys(380, 4);
const mSys = createSys(380, 7);
const sSys = createSys(280, 5);

function update(systems, val, angleStep, rStep) {
  const points = getPoints(String(Math.floor(val)).padStart(2, '0'));
  // Standard Clockwise Logic
  const angle = (90 - (val * angleStep)) * (Math.PI / 180);

  systems.forEach((sys, depth) => {
    const pos = sys.geometry.attributes.position.array;
    
    // The "Anchored" Radius logic you liked
    // Starts at 0.7 (near center) and moves out
    const r = 0.7 + (depth * rStep);
    
    const cx = Math.cos(angle) * r;
    const cy = Math.sin(angle) * r;

    for (let i = 0; i < pos.length / 3; i++) {
      const p = points[i % points.length] || { x: 0, y: 0 };
      
      // Magnetic Lerp
      pos[i * 3] += (cx + p.x - pos[i * 3]) * 0.18;
      pos[i * 3 + 1] += (cy + p.y - pos[i * 3 + 1]) * 0.18;
    }
    sys.geometry.attributes.position.needsUpdate = true;
  });
}

// --- ANIMATION ---
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
camera.position.set(0, -9, 9); // Perfect viewing angle

function animate() {
  requestAnimationFrame(animate);
  const d = new Date();
  const s = d.getSeconds() + d.getMilliseconds()/1000;
  const m = d.getMinutes() + s/60;
  const h = (d.getHours() % 12 || 12) + m/60;

  // The "Perfect" Spacing
  update(hSys, h, 30, 0.55);
  update(mSys, m, 6, 0.45);
  update(sSys, s, 6, 0.50);

  // Subtle Parallax (No dizzying spin)
  watchGroup.rotation.y = controls.getAzimuthalAngle() * 0.05;
  watchGroup.rotation.x = (controls.getPolarAngle() - Math.PI/2) * 0.05;

  controls.update();
  renderer.render(scene, camera);
}

animate();
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
